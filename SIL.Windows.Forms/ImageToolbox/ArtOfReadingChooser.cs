using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Diagnostics;
using System.Drawing;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Windows.Forms;
using L10NSharp;
using SIL.Reporting;
using SIL.Windows.Forms.Extensions;
using SIL.Windows.Forms.ImageGallery;

namespace SIL.Windows.Forms.ImageToolbox
{
	public partial class ArtOfReadingChooser : UserControl, IImageToolboxControl
	{
		private IImageCollection _imageCollection;
		private PalasoImage _previousImage;
		public bool InSomeoneElesesDesignMode;

		public ArtOfReadingChooser()
		{
			InitializeComponent();
			_thumbnailViewer.CaptionMethod = ((s) => string.Empty);//don't show a caption
			_thumbnailViewer.LoadComplete += ThumbnailViewerOnLoadComplete;
			_searchResultStats.Text = "";
			if (Environment.OSVersion.Platform == PlatformID.Unix)
			{
				// For Linux, we can install the package if requested.
				_downloadInstallerLink.Text = "Install the Art Of Reading package (this may be very slow)".Localize("ImageToolbox.InstallArtOfReading");
				_downloadInstallerLink.URL = null;
				_downloadInstallerLink.LinkClicked += InstallLinkClicked;
			}
			else
			{
				// Ensure that we can get localized text here.
				_downloadInstallerLink.Text = "Download Art Of Reading Installer".Localize("ImageToolbox.DownloadArtOfReading");
			}
			_labelSearch.Text = "Image Galleries".Localize("ImageToolbox.ImageGalleries");
			SearchLanguage = "en";	// until/unless the owner specifies otherwise explicitly
			// Get rid of any trace of a border on the toolstrip.
			toolStrip1.Renderer = new NoBorderToolStripRenderer();

			// For some reason, setting these BackColor values in InitializeComponent() doesn't work.
			// The BackColor gets set back to the standard control background color somewhere...
			_downloadInstallerLink.BackColor = Color.White;
			_messageLabel.BackColor = Color.White;
			_messageLabel.SizeChanged += MessageLabelSizeChanged;
		}

		public void Dispose()
		{
			_thumbnailViewer.Closing(); //this guy was working away in the background
			_messageLabel.SizeChanged -= MessageLabelSizeChanged;
		}

		/// <summary>
		/// use if the calling app already has some notion of what the user might be looking for (e.g. the definition in a dictionary program)
		/// </summary>
		/// <param name="searchTerm"></param>
		public void SetIntialSearchTerm(string searchTerm)
		{
			_searchTermsBox.Text = searchTerm;
		}

		/// <summary>
		/// Gets or sets the language used in searching for an image by words.
		/// </summary>
		public string SearchLanguage { get; set; }

		void _thumbnailViewer_SelectedIndexChanged(object sender, EventArgs e)
		{
			if(ImageChanged!=null && _thumbnailViewer.HasSelection)
			{
				ImageChanged.Invoke(this, null);
			}
		}

		private void _thumbnailViewer_DoubleClick(object sender, EventArgs e)
		{
			if (ImageChangedAndAccepted != null && _thumbnailViewer.HasSelection)
			{
				ImageChangedAndAccepted.Invoke(this, null);
			}
		}

		private void _searchButton_Click(object sender, EventArgs e)
		{
			Cursor.Current = Cursors.WaitCursor;
			_searchButton.Enabled = false;

			try
			{
				_thumbnailViewer.Clear();
				if (!string.IsNullOrWhiteSpace(_searchTermsBox.Text))
				{
					bool foundExactMatches;
					// (avoid enumerating the returned IEnumerable<object> more than once by copying to a List.)
					var results = _imageCollection.GetMatchingPictures(_searchTermsBox.Text, out foundExactMatches).ToList();
					if (results.Any())
					{
						_messageLabel.Visible = false;
						_downloadInstallerLink.Visible = false;
						_thumbnailViewer.LoadItems(_imageCollection.GetPathsFromResults(results, true));
						var fmt = "Found {0} images".Localize("ImageToolbox.MatchingImages", "The {0} will be replaced by the number of matching images");
						if (!foundExactMatches)
							fmt = "Found {0} images with names close to {1}".Localize("ImageToolbox.AlmostMatchingImages", "The {0} will be replaced by the number of images found.  The {1} will be replaced with the search string.");
						_searchResultStats.Text = string.Format(fmt, results.Count, _searchTermsBox.Text);
					}
					else
					{
						_messageLabel.Visible = true;
						if (!_searchLanguageMenu.Visible)
							_downloadInstallerLink.Visible = true;
						_searchResultStats.Text = "Found no matching images".Localize("ImageToolbox.NoMatchingImages");
					}
				}
			}
			catch (Exception error)
			{
			}
			_searchButton.Enabled = true;
			//_okButton.Enabled = false;
		}

		private void ThumbnailViewerOnLoadComplete(object sender, EventArgs eventArgs)
		{
			Cursor.Current = Cursors.Default;
		}

		public string ChosenPath { get { return _thumbnailViewer.SelectedPath; } }

		public bool HaveImageCollectionOnThisComputer
		{
			get { return _imageCollection != null; }
		}


		private void OnFormClosing(object sender, FormClosingEventArgs e)
		{
			_thumbnailViewer.Closing();
		}

		public void SetImage(PalasoImage image)
		{
			_previousImage = image;
			if(ImageChanged!=null)
				ImageChanged.Invoke(this,null);
		}

		public PalasoImage GetImage()
		{
			if(ChosenPath!=null &&  File.Exists(ChosenPath))
			{
				try
				{
					return PalasoImage.FromFile(ChosenPath);
				}
				catch (Exception error)
				{
					ErrorReport.ReportNonFatalExceptionWithMessage(error, "There was a problem choosing that image.");
					return _previousImage;
				}
			}
			return _previousImage;
		}

		public event EventHandler ImageChanged;
		/// <summary>
		/// happens when you double click an item
		/// </summary>
		public event EventHandler ImageChangedAndAccepted;

		private void _searchTermsBox_KeyDown(object sender, KeyEventArgs e)
		{
			if(e.KeyCode  ==Keys.Enter)
			{
				e.SuppressKeyPress = true;
				_searchButton_Click(sender, null);
			}
			else
			{
				_searchResultStats.Text = "";
			}
		}

		private new bool DesignMode
		{
			get
			{
				return (base.DesignMode || GetService(typeof(IDesignerHost)) != null) ||
					(LicenseManager.UsageMode == LicenseUsageMode.Designtime);
			}
		}

		private void ArtOfReadingChooser_Load(object sender, EventArgs e)
		{
			if (DesignMode)
				return;

			_imageCollection = ImageCollection.FromStandardLocations(SearchLanguage);
			_collectionToolStrip.Visible = false;
			if (_imageCollection == null)
			{
				_messageLabel.Visible = true;
				_messageLabel.Text = "This computer doesn't appear to have any galleries installed yet.".Localize("ImageToolbox.NoGalleries");
				_downloadInstallerLink.Visible = true;
				_searchTermsBox.Enabled = false;
				_searchButton.Enabled = false;
			}
			else
			{
#if DEBUG
				//  _searchTermsBox.Text = @"flower";
#endif
				SetupSearchLanguageChoice();
				_messageLabel.Visible = string.IsNullOrEmpty(_searchTermsBox.Text);
				// Adjust size to avoid text truncation
				_messageLabel.Height = 200;
				SetMessageLabelText();
				_thumbnailViewer.SelectedIndexChanged += new EventHandler(_thumbnailViewer_SelectedIndexChanged);
				if (_imageCollection.Collections.Count() > 1)
				{
					_collectionToolStrip.Visible = true;
					_collectionDropDown.Visible = true;
					_collectionDropDown.Text =
						"Galleries".Localize("ImageToolbox.Galleries");
					foreach (var collection in _imageCollection.Collections)
					{
						var text = Path.GetFileNameWithoutExtension(collection);
						var item = new ToolStripMenuItem(text);
						_collectionDropDown.DropDownItems.Add(item);
						item.CheckOnClick = true;
						item.CheckState = _imageCollection.IsCollectionEnabled(collection) ? CheckState.Checked : CheckState.Unchecked;
						item.CheckedChanged += (o, args) =>
						{
							if (_collectionDropDown.DropDownItems.Cast<ToolStripMenuItem>().Count(x => x.Checked) == 0)
								item.Checked = true; // tried to uncheck the last one, don't allow it.
							else
								_imageCollection.EnableCollection(collection, item.Checked);
						};
					}
				}
				else
				{
					// Pathologically, the user might have disabled this collection, then deleted all others
					// It's not so bad if he disabled some and then deleted all the enabled ones and still has
					// at least two (all disabled) because he can just re-enable one of them. But if we aren't
					// even showing that control he's had it, and also, in this case it's obvious which single
					// collection to enable.
					_imageCollection.EnableCollection(_imageCollection.Collections.First(), true);
				}
			}
			_messageLabel.Font = new Font(SystemFonts.DialogFont.FontFamily, 10);

#if DEBUG
			//if (!HaveImageCollectionOnThisComputer)
			//	return;
			//when just testing, I just want to see some choices.
			// _searchTermsBox.Text = @"flower";
			//_searchButton_Click(this,null);
#endif
		}

		private void SetMessageLabelText()
		{
			var msg = "In the box above, type what you are searching for, then press ENTER.".Localize("ImageToolbox.EnterSearchTerms");
			// Allow for the old index that contained English and Indonesian together.
			var searchLang = "English + Indonesian";
			// If we have the new multilingual index, _searchLanguageMenu will be visible.  Its tooltip
			// contains both the native name of the current search language + its English name in
			// parentheses if its in a nonRoman script or otherwise thought to be unguessable by a
			// literate speaker of an European language.  (The menu displays only the native name, and
			// SearchLanguage stores only the ISO code.)
			if (_searchLanguageMenu.Visible)
				searchLang = _searchLanguageMenu.ToolTipText;
			msg += Environment.NewLine + Environment.NewLine +
					String.Format("The search box is currently set to {0}".Localize("ImageToolbox.SearchLanguage"), searchLang);
			if (PlatformUtilities.Platform.IsWindows && !_searchLanguageMenu.Visible)
			{
				msg += Environment.NewLine + Environment.NewLine +
						"Did you know that there is a new version of this collection which lets you search in Arabic, Bengali, Chinese, English, French, Indonesian, Hindi, Portuguese, Spanish, Thai, or Swahili?  It is free and available for downloading."
							.Localize("ImageToolbox.NewMultilingual");
				_downloadInstallerLink.Visible = true;
				_downloadInstallerLink.BackColor = Color.White;
			}
			// Restore alignment (from center) for messages.  (See https://silbloom.myjetbrains.com/youtrack/issue/BL-2753.)
			_messageLabel.TextAlign = _messageLabel.RightToLeft==RightToLeft.Yes ? HorizontalAlignment.Right : HorizontalAlignment.Left;
			_messageLabel.Text = msg;
		}

		/// <summary>
		/// Position the download link label properly whenever the size of the main message label changes,
		/// whether due to changing its text or changing the overall dialog box size.  (BL-2853)
		/// </summary>
		private void MessageLabelSizeChanged(object sender, EventArgs eventArgs)
		{
			if (_searchLanguageMenu.Visible || !PlatformUtilities.Platform.IsWindows || !_downloadInstallerLink.Visible)
				return;
			_downloadInstallerLink.Width = _messageLabel.Width;		// not sure why this isn't automatic
			if (_downloadInstallerLink.Location.Y != _messageLabel.Bottom + 5)
				_downloadInstallerLink.Location = new Point(_downloadInstallerLink.Left, _messageLabel.Bottom + 5);
		}

		protected class LanguageChoice
		{
			static readonly List<string> idsOfRecognizableLanguages = new List<string> { "en", "fr", "es", "it", "tpi", "pt", "id" };
			private readonly CultureInfo _info;

			public LanguageChoice(CultureInfo ci)
			{
				_info = ci;
			}

			public string Id { get { return _info.Name == "zh-Hans" ? "zh" : _info.Name; } }

			public string NativeName { get { return _info.NativeName; } }

			public override string ToString()
			{
				if (_info.NativeName == _info.EnglishName)
					return _info.NativeName;	// English (English) looks rather silly...
				if (idsOfRecognizableLanguages.Contains(Id))
					return _info.NativeName;
				return $"{_info.NativeName} ({_info.EnglishName})"; // C#6 test
			}
		}

		private void SetupSearchLanguageChoice()
		{
			var indexLangs = _imageCollection.IndexLanguageIds;
			if (indexLangs == null)
			{
				_searchLanguageMenu.Visible = false;
			}
			else
			{
				_searchLanguageMenu.Visible = true;
				foreach (var id in indexLangs)
				{
					var ci = id == "zh" ? new CultureInfo("zh-Hans") : new CultureInfo(id);
					var choice = new LanguageChoice(ci);
					var item = _searchLanguageMenu.DropDownItems.Add(choice.ToString());
					item.Tag = choice;
					item.Click += SearchLanguageClick;
					if (id == SearchLanguage)
					{
						_searchLanguageMenu.Text = choice.NativeName;
						_searchLanguageMenu.ToolTipText = choice.ToString();
					}
				}
			}
			// The Mono renderer makes the toolstrip stick out.  (This is a Mono bug that
			// may not be worth spending time on.)  Let's not poke the user in the eye
			// with an empty toolstrip.
			if (Environment.OSVersion.Platform == PlatformID.Unix)
				toolStrip1.Visible = _searchLanguageMenu.Visible;
		}

		void SearchLanguageClick(object sender, EventArgs e)
		{
			var item = sender as ToolStripItem;
			if (item != null)
			{
				var lang = item.Tag as LanguageChoice;
				if (lang != null && SearchLanguage != lang.Id)
				{
					_searchLanguageMenu.Text = lang.NativeName;
					_searchLanguageMenu.ToolTipText = lang.ToString();
					SearchLanguage = lang.Id;
					_imageCollection.ReloadImageIndex(lang.Id);
					SetMessageLabelText();		// Update with new language name.
				}
			}
		}

		/// <summary>
		/// To actually focus on the search box, the Mono runtime library appears to
		/// first need us to focus the search button, wait a bit, and then focus the
		/// search box.  Bizarre, unfortunate, but true.  (One of those bugs that we
		/// couldn't write code to do if we tried!)
		/// See https://jira.sil.org/browse/BL-964.
		/// </summary>
		internal void FocusSearchBox()
		{
			_searchButton.GotFocus += _searchButtonGotSetupFocus;
			_searchButton.Select();
		}

		private System.Windows.Forms.Timer _focusTimer1;

		private void _searchButtonGotSetupFocus(object sender, EventArgs e)
		{
			_searchButton.GotFocus -= _searchButtonGotSetupFocus;
			_focusTimer1 = new System.Windows.Forms.Timer(this.components);
			_focusTimer1.Tick += new System.EventHandler(this._focusTimer1_Tick);
			_focusTimer1.Interval = 100;
			_focusTimer1.Enabled = true;
		}

		private void _focusTimer1_Tick(object sender, EventArgs e)
		{
			_focusTimer1.Enabled = false;
			_focusTimer1.Dispose();
			_focusTimer1 = null;
			_searchTermsBox.TextBox.Focus();
		}

		/// <summary>
		/// Try to install the artofreading package if possible.  Use a GUI program if
		/// possible, but if not, try the command-line program with a GUI password
		/// dialog.
		/// </summary>
		/// <remarks>
		/// On Windows, the link label opens a web page to let the user download the
		/// installer.  This is the analogous behavior for Linux, but is potentially
		/// so slow (300MB download) that we fire off the program without waiting for
		/// it to finish.
		/// </remarks>
		private void InstallLinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
		{
			if (Environment.OSVersion.Platform != PlatformID.Unix)
				return;
			// Install the artofreading package if at all possible.
			if (File.Exists("/usr/bin/software-center"))
			{
				using (var process = new Process())
				{
					process.StartInfo = new ProcessStartInfo {
						FileName = "/usr/bin/python",
						Arguments = "/usr/bin/software-center art-of-reading",
						UseShellExecute = false,
						RedirectStandardOutput = false,
						CreateNoWindow = false
					};
					process.Start();
				}
			}
			else if (File.Exists("/usr/bin/ssh-askpass"))
			{
				using (var process = new Process())
				{
					process.StartInfo = new ProcessStartInfo {
						FileName = "/usr/bin/sudo",
						Arguments = "-A /usr/bin/apt-get -y install art-of-reading",
						UseShellExecute = false,
						RedirectStandardOutput = false,
						CreateNoWindow = false
					};
					process.StartInfo.EnvironmentVariables.Add("SUDO_ASKPASS", "/usr/bin/ssh-askpass");
					process.Start();
				}
			}
		}
	}
}
